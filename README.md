<<<<<<< HEAD
# 设计模式 design pattern

当我们的代码量多起来的时候，或是当我们处于软件类行业时候。由于市场和客户的需求变化，我们需要对代码进行管理，然而每个人对需求实现的方法不同。以至于代码除了上帝就只有自己懂，甚至某些人的代码只有上帝能看懂（真的不是我）。所以为了充分体现面向对象的设计原则，充分利用面向对象的有利条件，前人总结了23种供于后人思考学习。
# 对象创建型模式
## 1.单例模式

一个类只有一个实例，这是为了节约资源的举动。有的类没必要创建多个实例比如，一些工厂类配置类，他们只需要一个实例即可。

### ·1.1懒汉模式

### ·1.2饿汉模式

### ·1.3静态内部类

### ·1.4枚举单例（简单方便而且线程安全同时还反序列化）
完美首选你值得拥有

## 2.工厂模式

工厂模式的初衷是为了规范new关键字的使用，在合适的时候，合适的地方，创建合适的对象。这样我们可以将创建和初始化对象的逻辑交给Factory来处理代码更加的合乎逻辑，更易于管理

### ·2.1简单工厂

其实,在某种程度上来说简单工厂并不属于工厂设计模式，我在《设计模式-可复用面向对象软件的基础》一书中并没有找到任何对它的描述。所以简单工厂充其量也只能算是一种设计的规范。但由于其是之后的工厂方法以及抽象工厂建立的基础，故列入此中。

### ·2.2工厂方法 Factory-Method

意图：定义一个用于创建对象的**接口**，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。

自己的理解：工厂方法不同于简单工厂直接返回一个具体的需要创建的类，工厂方法返回的是一个未知的类，而创建的逻辑需要子类自己去实现。也就是说工厂方法将创建的逻辑抽象出来了，形成了一个接口或者是一个抽象类（于此同时为了充分利用多态的特性，我们还需要将产品类的公共方法抽象得到一个Product接口）

### ·2.3抽象工厂

意图：提供一个接口以创建一系列相关或者相互依赖的对象，而无需指定他们具体的类

自己的理解：抽象工厂正如其名，是抽象的，定义抽象的接口让具体的工厂实现，定义抽象的产品族让具体的产品实现。

## 总结：

#### ·1.简单工厂只适用于关系简单的类，由于其违背了开闭原则在某种意义上不太适用于变化较多的项目中。

#### ·2.工厂方法将工厂和产品进行抽象，争强了扩展性，但是忽略了产品与产品之间的组合关系

#### ·3.抽象工厂满足了开闭原则，扩展性强，同时提供了对产品族的支持，我们可以自由灵活的组成各种各样的产品族。但是其实现的框架是3个工厂中最难，代码最长的。

#### **关于工厂的使用**

#### ··1.简单工厂：只有一类产品，产品之间没有联系。例如 RecyclerView中创建ViewHolder的工厂

#### ··2.工厂方法： 有多个工厂，每个工厂的产品之间没有组合关系，相当于只是将简单工厂的Factory和ViewHolder进行抽象，比如RecyclerView中创建多个自定义ViewHolder的工厂

#### ··3.抽象工厂：有多个工厂，每个工厂都能生成一系列的产品，产品之间存在组合关系。

## 3.建筑者模式 Builder
意图：将复杂对象的构建与它的表示分离，使得同样的构建过程中可以创建不同的表示。
### ·3.1 静态内部类实现
### ·3.2 抽象一个Builder，再新开一个类去继承
个人的理解：Builder Pattern与上一个Factory Pattern有比较大的相似度。但是呢，他们的不同点也很相同。
Factory Pattern注重的是将类创建出来。
然而Builder所关注的是如何将类给创建出来。
所以他们的关系在我看来是互补的，Builder确定创建的过程，Factory确定大体的框架。
#### 关于建筑者模式的使用
1.建筑者模式适用于创建复杂的对象。（不是复杂对象就没必要使用哦，杀鸡用牛刀不合适。）
2.建筑者模式需要掌握创建对象的细节。（既然需要掌握创建对象的细节，那么耦合性通常就不需要考虑，所以通常Builder是以内部类的方式创建）

## 4.原型模式
意图：用原型的实例指定创建对象的类型，并且通过拷贝这些原型创建新的对象

自己的理解：当我们需要创一个对象时候，于此同时这个对象的创建伴随着很多的配置项，我们已经创建过这个对象，那就偷懒直接*深拷贝*一份即可。





# 行为型模式
## 策略模式 Strategy
意图： 定义一系列的算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法可独立于使用它的客户而变化

自己的理解：策略模式就是利用接口将算法抽象进一个接口使得客户和算法相互分离，提高复用性。
## 中介者 Mediator
意图： 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互

自己地理解：中介者模式的目的是简化类与类之间的复杂关系，让对象只与中介者进行交互，从而达到解耦合的目的。其模式有点类似于MVC。除此之外其解耦的是系统内部的对象关系，而不是系统外。
### 总结：
#### 1.中介者的目的是为了解耦合复杂对象，简化类之间的复杂关系，如果类对象只有一俩个就没必要使用(因为这样的对象之间不存在复杂的对象关系，没必要简化)。
#### 2.通常中介者有两个接口，一个是抽象中介者本身，一个是抽象系统内部的类对象。但是如果系统内的类对象只于单一中介者打交道，那么中介者就没必要去抽象了(抽象是为了运用多态解离耦合，一个对象哪来的多态，耦合再高也没什么，关键是没有对象来替代完成它的职责)。





# 结构型模式
## 1.适配器模式Adapter
意图：将一个类的接口转化为客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容的那些类可以一起工作

自己的理解：Adapter适配器模式主要是为了将不兼容的系统兼容化，Adapter在其中发挥的作用类似于数据转接线，比如usb转type-c。
### 种类：
#### 1.对象适配器
#### 2.类适配器(由于Java Kotlin不支持多继承，所以没学，hh)
### 如何适配
创建一个Adapter类使得Adapter持有适配对象的引用，并实现不兼容接口。
### 适用条件
适用于接口不兼容
### 最后
接口不兼容是接口的规范有问题，总体架构设计的问题。设计过程中难以避免，总的来说Adapter就是为了解决问题而存在的。

## 2.装饰器模式Decorator
意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更加灵活。

自己的理解：Decorator的主要作用是在保证灵活性的同时为对象增加新的职责。在我个人的理解上来看，这个设计模式是一种扩展型的设计模式。它在语法上有一点类似于Adapter。Adapter是将不同的接口进行适配，适配过程中其实也是可以加扩展的，只是Adapter主要面向的是适配接口。这才使得它与Decorator有明显的区别。
### 如何构建
1.提供一个顶层的抽象类或者抽象接口。

2.明确要对哪一个类进行包装扩展。

3.新建一个包装抽象类，并继承自第一步的抽象类或者接口。

4.写包装类的实现类，同时记得要持有扩展对象的引用，因为在扩展的同时还得调用它。

5.实例化对象，对扩展对象一层层包装。

## 2.桥接模式
### 意图
讲抽象的部分与他的实现部分分离，使他可以独立的变化。
### 个人的理解
桥接模式类似于抽象工厂模式，抽象工厂是利用接口或是抽象类的继承来实现创建对象。
然而桥接模式是通过聚合关系，让一个抽象类持有接口最后让一个类去实现，从而达到创建的目的。
### 优点
1.桥接模式创建的对象耦合度较低，接口和实现进行了分离，实现可以组合。
2.可以独立的对接口和实现类进行扩充。
### 适用情况
1.想解耦合接口和实现。
2.度接口和实现进行任意的扩充而对client不造成影响
3.共享实现。
=======
# 设计模式
> 设计模式（Design Pattern）是前辈们对代码开发经验的总结，是***解决特定问题的一系列套路***。它***不是语法规定***，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的***解决方案***。

> 这 ***23*** 种设计模式的本质是**面向对象设计原则的实际运用**，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。

> 当然，软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择：
>
> - 对于简单的程序，可能写一个简单的算法要比引入某种设计模式更加容易；
> - 但是对于大型项目开发或者框架设计，用设计模式来组织代码显然更好。



## 设计模式的好处

- 可以提高程序员的思维能力、编程能力和设计能力。
- 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。
- 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。



## 设计模式的种类以及分类

两种分类方式

- 1.根据目的来分

> 根据模式是用来完成什么工作来划分，这种方式可分为***创建型模式、结构型模式和行为型***模式 3 种。
>
> 1. 创建型模式：***用于描述“怎样创建对象”***，它的主要特点是***“将对象的创建与使用分离”***。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
>
> 2. 结构型模式：***用于描述如何将类或对象按某种布局组成更大的结构***，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
>
>    *我更喜欢把它理解成搭积木，如何将小小的积木搭成高楼。这就是结构型所研究的事情*
>
> 3. 行为型模式：***用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务***，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。
>
>    行为型模式研究的是类与类的关系。日常开发中，通常会出现多个类之间的交互。如何处理这种交互就是行为型模式。

- 2.根据作用范围来分

> 1. 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。
> 2. 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。



## 设计模式一览

1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
3. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
4. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
5. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
6. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
7. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
8. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
9. 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
10. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
11. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
12. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
13. 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
14. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
15. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
16. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
17. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
18. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
19. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
20. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
21. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
22. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
23. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。



| 范   围\目的 | 创建型模式                | 结构型模式                                      |                        行为型模式                        |
| ------------ | ------------------------- | ----------------------------------------------- | :------------------------------------------------------: |
| 类模式       | 工厂方法                  | (类）适配器                                     |                     模板方法、解释器                     |
| 对象模式     | 单例,原型,抽象工厂,建造者 | 代理, (对象)适配器，桥接，装饰，外观，享元 组合 | 策略,命令,职责链,状态,观察者,中介者,迭代器,访问者,备忘录 |



## UML图基础

> 为什么要学UML？目的何在？
>
> 如果你看过设计模式的一些书籍你会发现。随着内容慢慢深入，代码基本上渐渐消失了。全部都是以UML图形来表示设计模式。如果看不懂UML那设计模式学起来就会很吃力。

### 类、接口表示

#### 类图

我们熟知，类存在3个比较重要的元素。

- 类名
- 属性
- 方法/函数

比如一个学生类的类图可以这样表示。

![image-20210721091328146](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721091328146.png)

分成3个部分：

最上面的部分是类名

中间是属性（成员变量）

最下面是方法（成员方法）



其中成员方法，成员函数都按照这样的格式书写

```
[可见性]名称(参数列表)[:返回类型]
```



类图中，需注意以下几点：

- 抽象类或抽象方法用斜体表示
- 如果是接口，则在类名上方加 <<Interface>>
- 字段和方法返回值的数据类型非必需
- 静态类或静态方法加下划线
- -,+,#,~分别对应可见性：private，public，protected，default

抽象类

![image-20210721193347433](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721193347433.png)

接口

![image-20210721193302353](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721193302353.png)

### 类之间的关系

UML 将事物之间的联系归纳为 6 种，并用对应的图形类表示。下面根据类与类之间的耦合度从弱到强排列。UML 中的类图有以下几种关系：**依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系**。其中泛化和实现的耦合度相等，它们是最强的。



#### 依赖关系

可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有**偶然性的、临时性的、非常弱的**。**但是B类的变化会影响到A**。表现在代码层面，为类B作为参数被类A在某个method方法中使用； 
![img](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/Dependence.jpg)



#### 关联关系

关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。

![image-20210721203002649](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721203002649.png)

##### 1.双向关联

![image-20210721203329110](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721203329110.png)

##### 2.单向关联

##### 3.自关联

有没有单向链表的既视感。

![image-20210721203524114](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721203524114.png)

##### 4.聚合关系

![image-20210721203916325](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721203916325.png)

##### 5.组合关系

![image-20210721204503653](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721204503653.png)



#### 泛化关系

![image-20210721205034098](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721205034098.png)

#### 接口与实现关系

![image-20210721213953368](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721213953368.png)





![image-20210721214053214](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210721214053214.png)

一个接口继承自另一个接口，一个接口依赖另一个接口

接口继承

```kotlin
interface InterfaceA {
    fun doA()
}

interface InterfaceB : InterfaceA {
    fun doB()
}

interface InterfaceC : InterfaceA {
    fun doC()
}
```

接口依赖

```kotlin
interface InterfaceA {
    fun doA()
}

interface InterfaceB {
    fun doB(interfaceA: InterfaceA)
}
```

 

### 类关系记忆技巧

|                             分类                             | 箭头特征                                      | 记忆技巧                                                     |
| :----------------------------------------------------------: | --------------------------------------------- | ------------------------------------------------------------ |
|                           箭头方向                           | 从子类指向父类                                | 定义子类需要通过 extends 关键字指定父类子类一定是知道父类定义的，但父类并不知道子类的定义只有知道对方信息时才能指向对方箭头的方向是从子类指向父类 |
|                          继承/实现                           | 用线条连接两个类； 空心三角箭头表示继承或实现 | 实线表示继承，是is-a的关系，表示扩展，不虚，很结实           |
|               虚线表示实现，虚线代表“虚”无实体               |                                               |                                                              |
|                          关联/依赖                           | 用线条连接两个类； 普通箭头表示关联或依赖     | 虚线表示依赖关系：临时用一下，若即若离，虚无缥缈，若有若无表示一种使用关系，一个类需要借助另一个类来实现功能一般一个类将另一个类作为参数使用，或作为返回值 |
| 实线表示关联关系：关系稳定，实打实的关系，“铁哥们”表示一个类对象和另一个类对象有关联通常一个类中有另一个类对象作为属性 |                                               |                                                              |
|                          组合/聚合                           | 用菱形表示：像一个盛东西的器皿（如盘子）      | 聚合：空心菱形，代表空器皿里可以放很多相同的东西，聚集在一起（箭头方向所指的类）整体和局部的关系，两者有独立的生命周期，是 has-a 的关系弱关系，消极的词：弱-空 |
| 组合：实心菱形，代表器皿里已经有实体结构的存在，生死与共整体与局部的关系，和聚合关系对比，关系更加强烈，两者具有相同的生命周期，contains-a 的关系强关系，积极的词；强-满 |                                               |                                                              |

除此之外，类关系图像上。

- 依赖和关联关系的主要区别是实线和虚线。
- 泛化和接口实现的主要区别也是实线和虚线。
- 泛化和接口实现的箭头都是空心箭头。
- 但是泛化与依赖的区别是箭头。



## 优秀设计框架的特性

所谓优秀的框架就是我们所谓的会写“好代码”的大神写出来的框架。这算是一种对优秀代码写法的规范，某种意义上有很大的参考性。

### 代码复用

无论是开发哪种软件产品，**成本和时间**都是最重要的。较少的开发时间意味着可以比竞争对手更早进入市场。较低的开发成本意味着能够留出更多的营销资金，覆盖更广泛的潜在客户。

其中，代码复用是减少开发成本最常用的方式之一，其目的非常明显，即：**与其反复从头开发，不如在新对象中重用已有的代码。**

### 扩展性

**需求变化是程序员生命中唯一不变的事情**。比如以下几种场景：

- 你在 Windows 平台上发布了一款游戏，现在人们想要 Mac OS 的版本。
- 你创建了一个使用方形按钮的 GUI 框架，但几个月后开始流行原型按钮。
- 你设计了一款优秀的电子商务网站，但仅仅几个月后，客户就要求新增电话订单的功能。



## 软件设计7大原则

在软件开发中，**为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性**，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。我们将在下面的几节中依次来介绍这 7 条原则，本节首先介绍开闭原则。

### 开闭原则

开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：**软件实体应当对扩展开放，对修改关闭**（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。



这里的软件实体包括以下几个部分：

1. 项目中划分出的模块
2. 类与接口
3. 方法

开闭原则的含义是：**当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。**



#### 开闭原则的作用

开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。

##### 1. 对软件测试的影响

软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。

##### 2. 可以提高代码的可复用性

粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。

##### 3. 可以提高软件的可维护性

遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

#### 开闭原则实现方法

可以通过“**抽象约束、封装变化**”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

![image-20210722081603719](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210722081603719.png)

**开闭原则需要扩展性，而扩展性需要低耦合。**（由于扩展性的定义是加入了新的实现或者模块对之前的模块不会造成影响。也就是说模块与模块之间是独立的，也即是低耦合。）而而耦合性可以通过接口进行分散。

***依赖抽象而不是具体实现。***



### 里氏替换原则

里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：**继承必须确保超类所拥有的性质在子类中仍然成立**（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。

里氏替换原则主要阐述了有关**继承的一些原则**，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

#### 里氏替换原则的作用

里氏替换原则的主要作用如下。

1. 里氏替换原则是实现开闭原则的重要方式之一。(感觉很突兀？里氏替换怎么就和开闭原则 扯上了呢?其实是这样的。我们在了解开闭原则的时候**第一的想法就是不能更改之前的代码**。但是如果你细心一点再跑去看看开闭原则的定义。你会发现不更改之前写过的代码其实是开闭原则的不完全概括。因为不修改之前的代码也能修改之前写个过的代码。**例子就是下面的鸟不会飞**。)
2. 它克服了继承中重写父类造成的可复用性变差的缺点。
3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。



#### 里氏替换原则的实现方法

里氏替换原则通俗来讲就是：**子类可以扩展父类的功能，但不能改变父类原有的功能**。也就是说：**子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法**。



如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：*取消原来的继承关系，重新设计它们之间的关系。*



关于里氏替换原则的例子，最有名的是“**正方形不是长方形**”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；**但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能**，所以它们**不能**定义成“鸟”的子类。同样，由于“气球鱼”**不会**游泳，所以**不能**定义成“鱼”的子类；“玩具炮”**炸不了**敌人，所以**不能**定义成“炮”的子类等。



![image-20210722093235671](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210722093235671.png)

```java
package principle;

public class LSPtest {
    public static void main(String[] args) {
        Bird bird1 = new Swallow();
        Bird bird2 = new BrownKiwi();
        bird1.setSpeed(120);
        bird2.setSpeed(120);
        System.out.println("如果飞行300公里：");
        try {
            System.out.println("燕子将飞行" + bird1.getFlyTime(300) + "小时.");
            System.out.println("几维鸟将飞行" + bird2.getFlyTime(300) + "小时。");
        } catch (Exception err) {
            System.out.println("发生错误了!");
        }
    }
}

//鸟类
class Bird {
    double flySpeed;

    public void setSpeed(double speed) {
        flySpeed = speed;
    }

    public double getFlyTime(double distance) {
        return (distance / flySpeed);
    }
}

//燕子类
class Swallow extends Bird {
}

//几维鸟类
class BrownKiwi extends Bird {
    public void setSpeed(double speed) {
        flySpeed = 0;
    }
}
```

![image-20210722093442151](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210722093442151.png)

***继承必须确保超类所拥有的性质在子类中仍然成立***



### 依赖倒置原则

依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特·马丁（Robert C.Martin）于 1996 年在 [C++](http://c.biancheng.net/cplus/) Report 上发表的文章。

依赖倒置原则的原始定义为：***高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象***（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：**要面向接口编程，不要面向实现编程。**

***依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。***



#### 依赖倒置原则的作用

依赖倒置原则的主要作用如下。

- 依赖倒置原则可以降低类间的耦合性。
- 依赖倒置原则可以提高系统的稳定性。
- 依赖倒置原则可以减少并行开发引起的风险。
- 依赖倒置原则可以提高代码的可读性和可维护性。



#### 依赖倒置原则的实现方法

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。

1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。

![image-20210722100702243](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210722100702243.png)

![image-20210722100801696](https://gitee.com/False_Mask/jetpack-demos-pics/raw/master/PicsAndGifs/image-20210722100801696.png)

这样代码可以这样写

```java
package principle;

public class DIPtest {
    public static void main(String[] args) {
        Customer wang = new Customer();
        System.out.println("顾客购买以下商品：");
        wang.shopping(new ShaoguanShop());
        wang.shopping(new WuyuanShop());
    }
}

//商店
interface Shop {
    public String sell(); //卖
}

//韶关网店
class ShaoguanShop implements Shop {
    public String sell() {
        return "韶关土特产：香菇、木耳……";
    }
}

//婺源网店
class WuyuanShop implements Shop {
    public String sell() {
        return "婺源土特产：绿茶、酒糟鱼……";
    }
}

//顾客
class Customer {
    public void shopping(Shop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
```
>>>>>>> f31b924 (更新了UML以及3条面向对象基本原则)
