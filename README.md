# 设计模式 design pattern

当我们的代码量多起来的时候，或是当我们处于软件类行业时候。由于市场和客户的需求变化，我们需要对代码进行管理，然而每个人对需求实现的方法不同。以至于代码除了上帝就只有自己懂，甚至某些人的代码只有上帝能看懂（真的不是我）。所以为了充分体现面向对象的设计原则，充分利用面向对象的有利条件，前人总结了23种供于后人思考学习。
# 对象创建型模式
## 1.单例模式

一个类只有一个实例，这是为了节约资源的举动。有的类没必要创建多个实例比如，一些工厂类配置类，他们只需要一个实例即可。

### ·1.1懒汉模式

### ·1.2饿汉模式

### ·1.3静态内部类

### ·1.4枚举单例（简单方便而且线程安全同时还反序列化）
完美首选你值得拥有

## 2.工厂模式

工厂模式的初衷是为了规范new关键字的使用，在合适的时候，合适的地方，创建合适的对象。这样我们可以将创建和初始化对象的逻辑交给Factory来处理代码更加的合乎逻辑，更易于管理

### ·2.1简单工厂

其实,在某种程度上来说简单工厂并不属于工厂设计模式，我在《设计模式-可复用面向对象软件的基础》一书中并没有找到任何对它的描述。所以简单工厂充其量也只能算是一种设计的规范。但由于其是之后的工厂方法以及抽象工厂建立的基础，故列入此中。

### ·2.2工厂方法 Factory-Method

意图：定义一个用于创建对象的**接口**，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。

自己的理解：工厂方法不同于简单工厂直接返回一个具体的需要创建的类，工厂方法返回的是一个未知的类，而创建的逻辑需要子类自己去实现。也就是说工厂方法将创建的逻辑抽象出来了，形成了一个接口或者是一个抽象类（于此同时为了充分利用多态的特性，我们还需要将产品类的公共方法抽象得到一个Product接口）

### ·2.3抽象工厂

意图：提供一个接口以创建一系列相关或者相互依赖的对象，而无需指定他们具体的类

自己的理解：抽象工厂正如其名，是抽象的，定义抽象的接口让具体的工厂实现，定义抽象的产品族让具体的产品实现。

## 总结：

#### ·1.简单工厂只适用于关系简单的类，由于其违背了开闭原则在某种意义上不太适用于变化较多的项目中。

#### ·2.工厂方法将工厂和产品进行抽象，争强了扩展性，但是忽略了产品与产品之间的组合关系

#### ·3.抽象工厂满足了开闭原则，扩展性强，同时提供了对产品族的支持，我们可以自由灵活的组成各种各样的产品族。但是其实现的框架是3个工厂中最难，代码最长的。

#### **关于工厂的使用**

#### ··1.简单工厂：只有一类产品，产品之间没有联系。例如 RecyclerView中创建ViewHolder的工厂

#### ··2.工厂方法： 有多个工厂，每个工厂的产品之间没有组合关系，相当于只是将简单工厂的Factory和ViewHolder进行抽象，比如RecyclerView中创建多个自定义ViewHolder的工厂

#### ··3.抽象工厂：有多个工厂，每个工厂都能生成一系列的产品，产品之间存在组合关系。

## 3.建筑者模式 Builder
意图：将复杂对象的构建与它的表示分离，使得同样的构建过程中可以创建不同的表示。
### ·3.1 静态内部类实现
### ·3.2 抽象一个Builder，再新开一个类去继承
个人的理解：Builder Pattern与上一个Factory Pattern有比较大的相似度。但是呢，他们的不同点也很相同。
Factory Pattern注重的是将类创建出来。
然而Builder所关注的是如何将类给创建出来。
所以他们的关系在我看来是互补的，Builder确定创建的过程，Factory确定大体的框架。
#### 关于建筑者模式的使用
1.建筑者模式适用于创建复杂的对象。（不是复杂对象就没必要使用哦，杀鸡用牛刀不合适。）
2.建筑者模式需要掌握创建对象的细节。（既然需要掌握创建对象的细节，那么耦合性通常就不需要考虑，所以通常Builder是以内部类的方式创建）

## 4.原型模式
意图：用原型的实例指定创建对象的类型，并且通过拷贝这些原型创建新的对象

自己的理解：当我们需要创一个对象时候，于此同时这个对象的创建伴随着很多的配置项，我们已经创建过这个对象，那就偷懒直接*深拷贝*一份即可。





# 行为型模式
## 策略模式 Strategy
意图： 定义一系列的算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法可独立于使用它的客户而变化

自己的理解：策略模式就是利用接口将算法抽象进一个接口使得客户和算法相互分离，提高复用性。
## 中介者 Mediator
意图： 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互

自己地理解：中介者模式的目的是简化类与类之间的复杂关系，让对象只与中介者进行交互，从而达到解耦合的目的。其模式有点类似于MVC。除此之外其解耦的是系统内部的对象关系，而不是系统外。
### 总结：
#### 1.中介者的目的是为了解耦合复杂对象，简化类之间的复杂关系，如果类对象只有一俩个就没必要使用(因为这样的对象之间不存在复杂的对象关系，没必要简化)。
#### 2.通常中介者有两个接口，一个是抽象中介者本身，一个是抽象系统内部的类对象。但是如果系统内的类对象只于单一中介者打交道，那么中介者就没必要去抽象了(抽象是为了运用多态解离耦合，一个对象哪来的多态，耦合再高也没什么，关键是没有对象来替代完成它的职责)。





# 结构型模式
## 1.适配器模式Adapter
意图：将一个类的接口转化为客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容的那些类可以一起工作

自己的理解：Adapter适配器模式主要是为了将不兼容的系统兼容化，Adapter在其中发挥的作用类似于数据转接线，比如usb转type-c。
### 种类：
#### 1.对象适配器
#### 2.类适配器(由于Java Kotlin不支持多继承，所以没学，hh)
### 如何适配
创建一个Adapter类使得Adapter持有适配对象的引用，并实现不兼容接口。
### 适用条件
适用于接口不兼容
### 最后
接口不兼容是接口的规范有问题，总体架构设计的问题。设计过程中难以避免，总的来说Adapter就是为了解决问题而存在的。

## 2.装饰器模式Decorator
意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更加灵活。

自己的理解：Decorator的主要作用是在保证灵活性的同时为对象增加新的职责。在我个人的理解上来看，这个设计模式是一种扩展型的设计模式。它在语法上有一点类似于Adapter。Adapter是将不同的接口进行适配，适配过程中其实也是可以加扩展的，只是Adapter主要面向的是适配接口。这才使得它与Decorator有明显的区别。
### 如何构建
1.提供一个顶层的抽象类或者抽象接口。

2.明确要对哪一个类进行包装扩展。

3.新建一个包装抽象类，并继承自第一步的抽象类或者接口。

4.写包装类的实现类，同时记得要持有扩展对象的引用，因为在扩展的同时还得调用它。

5.实例化对象，对扩展对象一层层包装。

## 2.桥接模式
### 意图
讲抽象的部分与他的实现部分分离，使他可以独立的变化。
### 个人的理解
桥接模式类似于抽象工厂模式，抽象工厂是利用接口或是抽象类的继承来实现创建对象。
然而桥接模式是通过聚合关系，让一个抽象类持有接口最后让一个类去实现，从而达到创建的目的。
### 优点
1.桥接模式创建的对象耦合度较低，接口和实现进行了分离，实现可以组合。
2.可以独立的对接口和实现类进行扩充。
### 适用情况
1.想解耦合接口和实现。
2.度接口和实现进行任意的扩充而对client不造成影响
3.共享实现。
