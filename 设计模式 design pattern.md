#设计模式 design pattern

当我们的代码量多起来的时候，或是当我们处于软件类行业时候。由于市场和客户的需求变化，我们需要对代码进行管理，然而每个人对需求实现的方法不同。以至于代码除了上帝就只有自己懂，甚至某些人的代码只有上帝能看懂（真的不是我）。所以为了充分体现面向对象的设计原则，充分利用面向对象的有利条件，前人总结了23种供于后人思考学习。
# 对象创建型模式
## 1.单例模式

 一个类只有一个实例，这是为了节约资源的举动。有的类没必要创建多个实例比如，一些工厂类配置类，他们只需要一个实例即可。

### ·1.1懒汉模式

### ·1.2饿汉模式

### ·1.3静态内部类

### ·1.4枚举单例（简单方便而且线程安全同时还反序列化）
 完美首选你值得拥有

## 2.工厂模式

 工厂模式的初衷是为了规范new关键字的使用，在合适的时候，合适的地方，创建合适的对象。这样我们可以将创建和初始化对象的逻辑交给Factory来处理代码更加的合乎逻辑，更易于管理

### ·2.1简单工厂

其实,在某种程度上来说简单工厂并不属于工厂设计模式，我在《设计模式-可复用面向对象软件的基础》一书中并没有找到任何对它的描述。所以简单工厂充其量也只能算是一种设计的规范。但由于其是之后的工厂方法以及抽象工厂建立的基础，故列入此中。

### ·2.2工厂方法 Factory-Method

意图：定义一个用于创建对象的**接口**，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。

自己的理解：工厂方法不同于简单工厂直接返回一个具体的需要创建的类，工厂方法返回的是一个未知的类，而创建的逻辑需要子类自己去实现。也就是说工厂方法将创建的逻辑抽象出来了，形成了一个接口或者是一个抽象类（于此同时为了充分利用多态的特性，我们还需要将产品类的公共方法抽象得到一个Product接口）

### ·2.3抽象工厂

意图：提供一个接口以创建一系列相关或者相互依赖的对象，而无需指定他们具体的类

自己的理解：抽象工厂正如其名，是抽象的，定义抽象的接口让具体的工厂实现，定义抽象的产品族让具体的产品实现。

##总结：

#### ·1.简单工厂只适用于关系简单的类，由于其违背了开闭原则在某种意义上不太适用于变化较多的项目中。

#### ·2.工厂方法将工厂和产品进行抽象，争强了扩展性，但是忽略了产品与产品之间的组合关系

#### ·3.抽象工厂满足了开闭原则，扩展性强，同时提供了对产品族的支持，我们可以自由灵活的组成各种各样的产品族。但是其实现的框架是3个工厂中最难，代码最长的。

#### **关于工厂的使用**

#### ··1.简单工厂：只有一类产品，产品之间没有联系。例如 RecyclerView中创建ViewHolder的工厂

#### ··2.工厂方法： 有多个工厂，每个工厂的产品之间没有组合关系，相当于只是将简单工厂的Factory和ViewHolder进行抽象，比如RecyclerView中创建多个自定义ViewHolder的工厂

#### ··3.抽象工厂：有多个工厂，每个工厂都能生成一系列的产品，产品之间存在组合关系。

## 3.建筑者模式 Builder
意图：将复杂对象的构建与它的表示分离，使得同样的构建过程中可以创建不同的表示。
### ·3.1 静态内部类实现
### ·3.2 抽象一个Builder，再新开一个类去继承
个人的理解：Builder Pattern与上一个Factory Pattern有比较大的相似度。但是呢，他们的不同点也很相同。
Factory Pattern注重的是将类创建出来。 
然而Builder所关注的是如何将类给创建出来。
所以他们的关系在我看来是互补的，Builder确定创建的过程，Factory确定大体的框架。
#### 关于建筑者模式的使用
1.建筑者模式适用于创建复杂的对象。（不是复杂对象就没必要使用哦，杀鸡用牛刀不合适。）
2.建筑者模式需要掌握创建对象的细节。（既然需要掌握创建对象的细节，那么耦合性通常就不需要考虑，所以通常Builder是以内部类的方式创建）

## 4.原型模式
意图：用原型的实例指定创建对象的类型，并且通过拷贝这些原型创建新的对象
自己的理解：当我们需要创一个对象时候，于此同时这个对象的创建伴随着很多的配置项，我们已经创建过这个对象，那就偷懒直接*深拷贝*一份即可。
